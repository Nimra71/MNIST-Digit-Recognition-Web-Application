# -*- coding: utf-8 -*-
"""MNIST_Digit_Recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uG7i73M5cEMjeI7MK0QHtuBFgremAvDe

1. Import Libraries
"""

!pip install tensorflow opencv-python gradio matplotlib

"""2. Load MNIST Dataset, Data Preprocessing, Model Training, Model Evaluation"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

# Load MNIST
(X_train, y_train), (X_test, y_test) = mnist.load_data()

# Normalize
X_train = X_train / 255.0
X_test = X_test / 255.0

# Reshape for CNN
X_train = X_train.reshape(-1,28,28,1)
X_test = X_test.reshape(-1,28,28,1)

# Build CNN Model
model = Sequential([
    Conv2D(32, (3,3), activation='relu', input_shape=(28,28,1)),
    MaxPooling2D(2,2),
    Conv2D(64, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.3),
    Dense(10, activation='softmax')
])

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Callbacks
early_stop = EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True)
checkpoint = ModelCheckpoint("best_mnist_model.h5", save_best_only=True)

# Train
history = model.fit(
    X_train, y_train,
    validation_data=(X_test, y_test),
    epochs=15,
    callbacks=[early_stop, checkpoint]
)

# Evaluate
loss, acc = model.evaluate(X_test, y_test)
print("âœ… Test Accuracy:", acc)

"""3. Visualization (Accuracy & Loss Graphs)"""

plt.figure(figsize=(12,4))

plt.subplot(1,2,1)
plt.plot(history.history['accuracy'], label='Train')
plt.plot(history.history['val_accuracy'], label='Validation')
plt.title("Accuracy Curve")
plt.legend()

plt.subplot(1,2,2)
plt.plot(history.history['loss'], label='Train')
plt.plot(history.history['val_loss'], label='Validation')
plt.title("Loss Curve")
plt.legend()

plt.show()

"""4. Image Preprocessing for Model Prediction"""

def preprocess_image(img):
    img = np.array(img)

    # Convert to grayscale if needed
    if len(img.shape) == 3:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Remove noise
    img = cv2.GaussianBlur(img, (5,5), 0)

    # Threshold (make digit white)
    _, img = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    # Resize to MNIST format
    img = cv2.resize(img, (28,28))

    # Normalize
    img = img / 255.0
    img = img.reshape(1,28,28,1)

    return img

"""5. Model Prediction"""

def predict_digit(img):
    processed = preprocess_image(img)
    preds = model.predict(processed)[0]

    digit = np.argmax(preds)
    confidence = preds[digit] * 100

"""6. Building the Interactive Web App"""

import gradio as gr

iface = gr.Interface(
    fn=predict_digit,
    inputs=gr.Image(type="pil"),
    outputs="text",
    title="ðŸ§  Professional MNIST Digit Recognizer",
    description="Upload a handwritten digit image (white digit on dark background works best)"
)

iface.launch()